# Agent Mode Instructions for Asteroids Game Development

## ğŸ¯ Project Context

You are continuing development of a fully functional Asteroids game built in C++ with Raylib. The core game mechanics are complete and working perfectly. Your role is to add polish features and game systems.

## ğŸ“‹ Current State

### âœ… What's Working (DO NOT BREAK)
- Ship movement, rotation, and physics (WASD + Arrow key controls)
- Bullet shooting with proper physics
- Asteroid spawning, movement, and splitting mechanics
- Collision detection between bullets and asteroids
- Screen wrapping for all objects
- Memory management with proper cleanup
- **COMPLETED PHASE 1**: Score system, Lives system, Game state management, Wave progression system
- **Safe spawn system**: Player-controlled timing for wave transitions and respawns
- **Clean state management**: GameState enum (MENU, WAVE_TRANSITION, WAITING_TO_SPAWN, PLAYING, PAUSED, GAME_OVER)

### ğŸ“ File Structure
```
c:\Projects\Asteroids\
â”œâ”€â”€ .vscode/          # VS Code configuration (configured)
â”œâ”€â”€ src/
â”‚   â””â”€â”€ asteroids.cpp # Main game file (~640 lines, Phase 1 complete)
â”œâ”€â”€ Makefile          # Build system (configured)
â””â”€â”€ [context files]   # README, roadmap, etc.
```

### ğŸ—ï¸ Code Architecture Understanding
- **Game Loop**: Clear UPDATE/DRAW separation
- **Structures**: Ship, Bullet, Asteroid with proper encapsulation  
- **Physics**: Momentum-based movement with drag and speed limiting
- **Memory**: std::vector containers with erase/remove_if cleanup
- **Collision**: Circle-based distance calculations
- **Utilities**: RotatePoint function for vector math

## ğŸ¯ Development Approach

### Implementation Rules
1. **Preserve existing functionality** - Never break what's working
2. **Follow existing patterns** - Use established code style and architecture
3. **One feature at a time** - Complete implementations before moving on
4. **Test thoroughly** - Ensure each addition works and doesn't break existing code
5. **Maintain performance** - Keep 60 FPS smooth gameplay

### Code Style Guidelines
- Use existing naming conventions (camelCase for variables, PascalCase for structs)
- Maintain UPDATE/DRAW section separation
- Follow existing vector management patterns
- Use raylib functions consistently with current usage
- Add features as new code blocks, don't refactor existing working code
- **CRITICAL**: When wrapping existing code in new conditionals, preserve exact indentation
- **CRITICAL**: When making multi-part edits, carefully maintain code structure integrity
- Always use consistent 4-space indentation (match existing pattern)
- When moving code blocks, verify all opening/closing braces align properly

### Large Refactoring Safety Rules
- **AVOID major architectural changes** unless absolutely necessary
- **When refactoring state management**: Make incremental changes, test each step
- **Before large edits**: Read entire affected sections to understand dependencies
- **After structural changes**: Always build immediately to catch syntax errors
- **If compilation fails**: Fix ALL errors before continuing with new features
- **Prefer small, focused changes** over large multi-file refactoring operations
- **When removing variables**: Check ALL references before deletion
- **Document breaking changes** immediately for context

### Priority Order
Follow the roadmap priority order:
1. **Phase 1**: âœ… COMPLETE (Score system, Lives system, Game states, Wave system, Safe spawn)
2. **Phase 2**: Audio â†’ Particles â†’ UI polish  
3. **Phase 3**: Advanced graphics â†’ High scores â†’ Power-ups

## ğŸš€ Specific Implementation Guidelines

### When Adding New Features:
1. **Read existing code** to understand current patterns
2. **Add new structs/variables** after existing declarations
3. **Update logic** in appropriate UPDATE sections
4. **Add rendering** in appropriate DRAW sections
5. **When wrapping existing code**: Make smaller, more careful edits to preserve structure
6. **Verify indentation** matches existing patterns exactly
7. **Test immediately** after implementation

### Key Technical Details:
- **Screen size**: 800x600 pixels
- **Frame rate**: 60 FPS target
- **Physics**: No GetFrameTime() usage (direct pixel movement)
- **Collision radii**: Large(30), Medium(20), Small(10) + bullet(2)
- **Ship rotation**: 3.0f degrees per frame
- **Thrust power**: 0.5f per frame
- **Bullet speed**: 8.0f additional velocity

### Error Prevention:
- Always check `active` flags before processing objects
- Remember to clean up inactive objects with erase/remove_if
- Maintain proper collision detection order (bullets first, then asteroids)
- Screen wrap at exact screen dimensions (0 to screenWidth/screenHeight)

## ğŸ® User Experience Goals

### Maintain Classic Feel
- Preserve authentic Asteroids physics and feel
- Keep controls responsive and smooth
- Maintain challenging but fair gameplay

### Add Modern Polish
- Smooth visual feedback
- Clear UI presentation
- Intuitive state transitions
- Satisfying audio feedback

## ğŸ” Testing Requirements

After each feature implementation:
- [ ] Game compiles and runs without errors
- [ ] New feature functions as designed
- [ ] All existing mechanics still work correctly
- [ ] No performance degradation
- [ ] No memory leaks or crashes
- [ ] Visual presentation is clean and readable

## ğŸ“ Documentation Expectations

For each feature added:
1. **Comment major additions** in code
2. **Update this file** with implementation notes
3. **Note any architectural changes** 
4. **Record any challenges/solutions** for future reference

---
*Goal: Transform the complete core game into a polished, feature-rich Asteroids experience*